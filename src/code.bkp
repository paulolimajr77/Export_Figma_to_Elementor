// Elementor JSON Compiler – Full Implementation (TypeScript)
// Exporta frames do Figma para JSON compatível com Elementor (clipboard).
// Suporta containers, textos, botões, imagem, icon, icon-box, image-box, etc.

// -------------------- Interfaces --------------------
interface ElementorSettings {
    [key: string]: any;
}

interface ElementorElement {
    id: string;
    elType: string;
    widgetType?: string;
    settings: ElementorSettings;
    elements: ElementorElement[];
    isInner?: boolean;
}

interface ElementorTemplate {
    type: string;
    siteurl: string;
    elements: ElementorElement[];
    version: string;
}

// -------------------- Geometry Type --------------------
type GeometryNode =
    | RectangleNode
    | EllipseNode
    | PolygonNode
    | StarNode
    | VectorNode
    | TextNode
    | FrameNode
    | ComponentNode
    | InstanceNode
    | BooleanOperationNode
    | LineNode;

// -------------------- Helper Utilities --------------------
function generateGUID(): string {
    return 'xxxxxxxxxx'.replace(/[x]/g, () => ((Math.random() * 36) | 0).toString(36));
}

function convertColor(paint: SolidPaint): string {
    if (!paint || paint.type !== 'SOLID') return '';
    const { r, g, b } = paint.color;
    const a = paint.opacity !== undefined ? paint.opacity : 1;
    return `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
}

// -------------------- Type Guards --------------------
function hasFills(node: SceneNode): node is GeometryNode {
    return 'fills' in node;
}

function hasStrokes(node: SceneNode): node is GeometryNode {
    return 'strokes' in node;
}

function hasEffects(node: SceneNode): node is SceneNode & { effects: ReadonlyArray<Effect> } {
    return 'effects' in node;
}

function hasLayout(node: SceneNode): node is FrameNode | ComponentNode | InstanceNode {
    return 'layoutMode' in node;
}

function hasCornerRadius(node: SceneNode): node is FrameNode | RectangleNode | ComponentNode | InstanceNode {
    return 'cornerRadius' in node || 'topLeftRadius' in node;
}

// -------------------- Extraction Functions --------------------
function extractTypography(node: TextNode): ElementorSettings {
    const settings: ElementorSettings = {};
    settings.typography_typography = 'custom';

    if (node.fontSize !== figma.mixed) {
        settings.typography_font_size = { unit: 'px', size: Math.round(node.fontSize) };
    }
    if (node.fontName !== figma.mixed) {
        const style = node.fontName.style.toLowerCase();
        if (style.includes('bold')) settings.typography_font_weight = '700';
        else if (style.includes('semibold')) settings.typography_font_weight = '600';
        else if (style.includes('medium')) settings.typography_font_weight = '500';
        else if (style.includes('light')) settings.typography_font_weight = '300';
        else settings.typography_font_weight = '400';

        if (style.includes('italic')) settings.typography_font_style = 'italic';
        settings.typography_font_family = node.fontName.family;
    }
    if (node.lineHeight !== figma.mixed && node.lineHeight.unit !== 'AUTO') {
        if (node.lineHeight.unit === 'PIXELS') {
            settings.typography_line_height = { unit: 'px', size: Math.round(node.lineHeight.value) };
        } else if (node.lineHeight.unit === 'PERCENT') {
            settings.typography_line_height = { unit: 'em', size: (node.lineHeight.value / 100).toFixed(2) };
        }
    }
    if (node.letterSpacing !== figma.mixed && node.letterSpacing.value !== 0) {
        settings.typography_letter_spacing = { unit: 'px', size: node.letterSpacing.value };
    }
    if (node.textAlignHorizontal) {
        const map: Record<string, string> = { LEFT: 'left', CENTER: 'center', RIGHT: 'right', JUSTIFIED: 'justify' };
        const key = node.textAlignHorizontal as string;
        if (map[key]) settings.align = map[key];
    }
    if (node.textDecoration !== figma.mixed) {
        if (node.textDecoration === 'UNDERLINE') settings.typography_text_decoration = 'underline';
        else if (node.textDecoration === 'STRIKETHROUGH') settings.typography_text_decoration = 'line-through';
    }
    if (node.textCase !== figma.mixed) {
        if (node.textCase === 'UPPER') settings.typography_text_transform = 'uppercase';
        else if (node.textCase === 'LOWER') settings.typography_text_transform = 'lowercase';
        else if (node.textCase === 'TITLE') settings.typography_text_transform = 'capitalize';
    }
    return settings;
}

function extractTextColor(node: TextNode): string {
    if (!hasFills(node) || !Array.isArray(node.fills) || node.fills.length === 0) return '';
    const fill = node.fills[0];
    if (fill.type === 'SOLID') return convertColor(fill);
    return '';
}

function extractBorderStyles(node: SceneNode): ElementorSettings {
    const settings: ElementorSettings = {};
    if (hasStrokes(node) && Array.isArray(node.strokes) && node.strokes.length > 0) {
        const stroke = node.strokes[0];
        if (stroke.type === 'SOLID') {
            settings.border_color = convertColor(stroke);
            settings.border_border = 'solid';
            if ((node as any).strokeWeight !== figma.mixed) {
                const w = (node as any).strokeWeight;
                settings.border_width = {
                    unit: 'px',
                    top: w,
                    right: w,
                    bottom: w,
                    left: w,
                    isLinked: true
                };
            }
        }
    }
    if (hasCornerRadius(node)) {
        const anyNode: any = node;
        if (anyNode.cornerRadius !== figma.mixed && typeof anyNode.cornerRadius === 'number') {
            const r = anyNode.cornerRadius;
            settings.border_radius = {
                unit: 'px',
                top: r,
                right: r,
                bottom: r,
                left: r,
                isLinked: true
            };
        } else {
            settings.border_radius = {
                unit: 'px',
                top: anyNode.topLeftRadius || 0,
                right: anyNode.topRightRadius || 0,
                bottom: anyNode.bottomRightRadius || 0,
                left: anyNode.bottomLeftRadius || 0,
                isLinked: false
            };
        }
    }
    return settings;
}

function extractShadows(node: SceneNode): ElementorSettings {
    const settings: ElementorSettings = {};
    if (!hasEffects(node) || !Array.isArray(node.effects)) return settings;
    const drop = node.effects.find(e => e.type === 'DROP_SHADOW' && e.visible !== false) as DropShadowEffect | undefined;
    if (drop) {
        const { color, offset, radius, spread } = drop;
        const rgba = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, ${color.a})`;
        settings.box_shadow_box_shadow_type = 'yes';
        settings.box_shadow_box_shadow = {
            horizontal: Math.round(offset.x),
            vertical: Math.round(offset.y),
            blur: Math.round(radius),
            spread: Math.round(spread || 0),
            color: rgba
        };
    }
    return settings;
}

function extractInnerShadow(node: SceneNode): ElementorSettings {
    const settings: ElementorSettings = {};
    if (!hasEffects(node) || !Array.isArray(node.effects)) return settings;
    const inner = node.effects.find(e => e.type === 'INNER_SHADOW' && e.visible !== false) as InnerShadowEffect | undefined;
    if (inner) {
        const { color, offset, radius, spread } = inner;
        const rgba = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, ${color.a})`;
        settings.box_shadow_box_shadow_type_inner = 'yes';
        settings.box_shadow_box_shadow_inner = {
            horizontal: Math.round(offset.x),
            vertical: Math.round(offset.y),
            blur: Math.round(radius),
            spread: Math.round(spread || 0),
            color: rgba,
            position: 'inset'
        };
    }
    return settings;
}

function extractOpacity(node: SceneNode): ElementorSettings {
    if ('opacity' in node && node.opacity !== 1) {
        return { _opacity: { unit: 'px', size: node.opacity } };
    }
    return {};
}

function extractTextShadow(node: TextNode): ElementorSettings {
    const settings: ElementorSettings = {};
    if (!hasEffects(node) || !Array.isArray(node.effects)) return settings;
    const drop = node.effects.find(e => e.type === 'DROP_SHADOW' && e.visible !== false) as DropShadowEffect | undefined;
    if (drop) {
        const { color, offset, radius } = drop;
        const rgba = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, ${color.a})`;
        settings.text_shadow_text_shadow_type = 'yes';
        settings.text_shadow_text_shadow = {
            horizontal: `${Math.round(offset.x)}px`,
            vertical: `${Math.round(offset.y)}px`,
            blur: `${Math.round(radius)}px`,
            color: rgba
        };
    }
    return settings;
}

function extractTransform(node: SceneNode): ElementorSettings {
    const settings: ElementorSettings = {};
    if ('rotation' in node && node.rotation !== 0) {
        settings._transform_rotate_popover = 'custom';
        settings._transform_rotateZ_effect = { unit: 'deg', size: Math.round(node.rotation) };
    }
    return settings;
}

function extractBlendMode(node: SceneNode): ElementorSettings {
    if (!('blendMode' in node) || node.blendMode === 'PASS_THROUGH' || node.blendMode === 'NORMAL') return {};
    const map: Record<string, string> = {
        MULTIPLY: 'multiply',
        SCREEN: 'screen',
        OVERLAY: 'overlay',
        DARKEN: 'darken',
        LIGHTEN: 'lighten',
        COLOR_DODGE: 'color-dodge',
        COLOR_BURN: 'color-burn',
        HARD_LIGHT: 'hard-light',
        SOFT_LIGHT: 'soft-light',
        DIFFERENCE: 'difference',
        EXCLUSION: 'exclusion',
        HUE: 'hue',
        SATURATION: 'saturation',
        COLOR: 'color',
        LUMINOSITY: 'luminosity'
    };
    const css = map[node.blendMode];
    if (css) return { _css_blend_mode: css };
    return {};
}

function extractCSSFilters(node: SceneNode): ElementorSettings {
    if (!hasEffects(node) || !Array.isArray(node.effects)) return {};
    const filters: string[] = [];
    node.effects.forEach(e => {
        if (e.visible === false) return;
        if (e.type === 'LAYER_BLUR' || e.type === 'BACKGROUND_BLUR') {
            filters.push(`blur(${Math.round(e.radius)}px)`);
        }
    });
    if (filters.length) return { _css_filter: filters.join(' ') };
    return {};
}

function extractOverflow(node: SceneNode): ElementorSettings {
    if ('clipsContent' in node && node.clipsContent) return { _overflow: 'hidden' };
    return {};
}

function extractPadding(node: SceneNode): ElementorSettings {
    const frame = node as FrameNode;
    const top = (frame as any).paddingTop ?? 0;
    const right = (frame as any).paddingRight ?? 0;
    const bottom = (frame as any).paddingBottom ?? 0;
    const left = (frame as any).paddingLeft ?? 0;
    const isLinked = top === right && top === bottom && top === left;
    return {
        padding: {
            unit: 'px',
            top: String(top),
            right: String(right),
            bottom: String(bottom),
            left: String(left),
            isLinked
        }
    };
}

function extractMargin(node: SceneNode): ElementorSettings {
    const parent = node.parent as BaseNode | null;
    if (!parent || !('layoutMode' in parent) || (parent as any).layoutMode !== 'NONE') return {};
    const margin: ElementorSettings = {};
    const threshold = 5;
    if ((node as any).y > threshold) margin.margin_top = { unit: 'px', size: Math.round((node as any).y) };
    if ((node as any).x > threshold) margin.margin_left = { unit: 'px', size: Math.round((node as any).x) };
    if ('width' in parent) {
        const rightSpace = (parent as any).width - ((node as any).x + (node as any).width);
        if (rightSpace > threshold) margin.margin_right = { unit: 'px', size: Math.round(rightSpace) };
    }
    if ('height' in parent) {
        const bottomSpace = (parent as any).height - ((node as any).y + (node as any).height);
        if (bottomSpace > threshold) margin.margin_bottom = { unit: 'px', size: Math.round(bottomSpace) };
    }
    return margin;
}

function extractPositioning(node: SceneNode): ElementorSettings {
    const settings: ElementorSettings = {};
    if ('constraints' in node) {
        const h = node.constraints.horizontal;
        const v = node.constraints.vertical;
        if (h === 'MAX') {
            settings._position = 'absolute';
            settings._offset_orientation_h = 'end';
            settings._offset_x = { unit: 'px', size: 0 };
        }
        if (v === 'MAX') {
            settings._position = 'absolute';
            settings._offset_orientation_v = 'end';
            settings._offset_y = { unit: 'px', size: 0 };
        }
    }
    const name = node.name.toLowerCase();
    if (name.includes('fixed')) {
        settings._position = 'fixed';
        settings._offset_x = { unit: 'px', size: Math.round((node as any).x) };
        settings._offset_y = { unit: 'px', size: Math.round((node as any).y) };
    } else if (name.includes('sticky')) {
        settings._position = 'sticky';
        settings._offset_y = { unit: 'px', size: 0 };
    }
    if (node.parent && 'children' in node.parent) {
        const siblings = (node.parent as any).children as SceneNode[];
        const index = siblings.indexOf(node);
        const z = siblings.length - index;
        if (z > 1) settings._z_index = z;
    }
    return settings;
}

function extractDimensions(node: SceneNode): ElementorSettings {
    const dims: ElementorSettings = {};
    if ('width' in node) dims.width = { unit: 'px', size: Math.round((node as any).width) };
    if ('height' in node) dims.height = { unit: 'px', size: Math.round((node as any).height) };
    return dims;
}

function extractBackgroundAdvanced(node: SceneNode): ElementorSettings {
    const settings: ElementorSettings = {};
    if (!hasFills(node) || !Array.isArray(node.fills) || node.fills.length === 0) return settings;

    const fill = node.fills[node.fills.length - 1] as Paint;
    if (!fill.visible) return settings;

    if (fill.type === 'SOLID') {
        settings.background_background = 'classic';
        settings.background_color = convertColor(fill as SolidPaint);
    } else if (fill.type === 'GRADIENT_LINEAR') {
        const g = fill;
        settings.background_background = 'gradient';
        settings.background_gradient_type = 'linear';
        if (g.gradientStops.length >= 2) {
            settings.background_color = convertColor({
                type: 'SOLID',
                color: g.gradientStops[0].color,
                opacity: g.gradientStops[0].color.a
            } as SolidPaint);
            settings.background_color_b = convertColor({
                type: 'SOLID',
                color: g.gradientStops[g.gradientStops.length - 1].color,
                opacity: g.gradientStops[g.gradientStops.length - 1].color.a
            } as SolidPaint);
            settings.background_gradient_angle = { unit: 'deg', size: 180 };
        }
    }
    return settings;
}

function extractCustomCSS(_node: SceneNode): ElementorSettings {
    return {};
}

function extractFlexLayout(node: SceneNode): ElementorSettings {
    if (!hasLayout(node) || node.layoutMode === 'NONE') return {};

    const settings: ElementorSettings = {};
    const isRow = node.layoutMode === 'HORIZONTAL';

    settings.flex_direction = isRow ? 'row' : 'column';

    const justifyMap: Record<string, string> = {
        MIN: 'start',
        CENTER: 'center',
        MAX: 'end',
        SPACE_BETWEEN: 'space-between'
    };
    if (node.primaryAxisAlignItems && justifyMap[node.primaryAxisAlignItems]) {
        settings.justify_content = justifyMap[node.primaryAxisAlignItems];
    }

    const alignMap: Record<string, string> = {
        MIN: 'start',
        CENTER: 'center',
        MAX: 'end',
        BASELINE: 'baseline'
    };
    if (node.counterAxisAlignItems && alignMap[node.counterAxisAlignItems]) {
        settings.align_items = alignMap[node.counterAxisAlignItems];
    }

    if (node.itemSpacing && node.itemSpacing > 0) {
        settings.gap = {
            unit: 'px',
            size: node.itemSpacing,
            column: node.itemSpacing,
            row: node.itemSpacing,
            isLinked: true
        };
    }

    settings.flex_wrap = node.layoutWrap === 'WRAP' ? 'wrap' : 'nowrap';

    return settings;
}

function isIconNode(node: SceneNode): boolean {
    const vectorTypes = ['VECTOR', 'STAR', 'ELLIPSE', 'POLYGON', 'BOOLEAN_OPERATION', 'LINE'];
    const isVector = vectorTypes.includes(node.type);
    const isSmallFrame = (node.type === 'FRAME' || node.type === 'INSTANCE') && (node as any).width <= 50 && (node as any).height <= 50;
    const name = node.name.toLowerCase();
    return isVector || isSmallFrame || name.includes('icon') || name.includes('vector');
}

function hasImageFill(node: GeometryNode): boolean {
    return hasFills(node) && Array.isArray(node.fills) && node.fills.some(p => p.type === 'IMAGE');
}

// -------------------- Media Export Functions --------------------
async function exportNodeAsSvg(node: SceneNode): Promise<Uint8Array | null> {
    try {
        const bytes = await node.exportAsync({ format: 'SVG' });
        return bytes;
    } catch (e) {
        console.error(`[F2E] Failed to export SVG for "${node.name}" (${node.id}):`, e);
        return null;
    }
}

async function exportNodeAsPng(node: SceneNode): Promise<Uint8Array | null> {
    try {
        const bytes = await node.exportAsync({ format: 'PNG', constraint: { type: 'SCALE', value: 2 } });
        return bytes;
    } catch (e) {
        console.error(`[F2E] Failed to export PNG for "${node.name}" (${node.id}):`, e);
        return null;
    }
}

// -------------------- Widget Creation --------------------
function createTextWidget(node: TextNode): ElementorElement {
    const isHeading =
        (node.fontSize as number) > 24 ||
        (node.fontName as FontName).style.toLowerCase().includes('bold');

    const widgetType = isHeading ? 'heading' : 'text-editor';
    const settings: ElementorSettings = { title: node.characters, editor: node.characters };

    Object.assign(settings, extractTypography(node));
    const color = extractTextColor(node);
    if (color) {
        settings.title_color = color;
        settings.text_color = color;
    }
    Object.assign(settings, extractShadows(node));
    Object.assign(settings, extractTextShadow(node));
    Object.assign(settings, extractOpacity(node));
    Object.assign(settings, extractTransform(node));
    Object.assign(settings, extractPositioning(node));
    Object.assign(settings, extractMargin(node));

    return { id: generateGUID(), elType: 'widget', widgetType, settings, elements: [] };
}

// -------------------- Main Compiler Class --------------------
class ElementorCompiler {
    pendingUploads: Map<string, (result: any) => void> = new Map();
    wpConfig: any;

    constructor(config: any) {
        this.wpConfig = config || {};
        this.pendingUploads = new Map();
    }

    async uploadImageToWordPress(node: SceneNode, format: 'PNG' | 'SVG'): Promise<string | null> {
        if (!this.wpConfig || !this.wpConfig.url || !this.wpConfig.user || !this.wpConfig.password) {
            return null;
        }

        try {
            let bytes: Uint8Array | null = null;
            let mimeType = '';

            if (format === 'SVG') {
                bytes = await exportNodeAsSvg(node);
                mimeType = 'image/svg+xml';
            } else {
                bytes = await exportNodeAsPng(node);
                mimeType = 'image/png';
            }

            if (!bytes) return null;

            const id = generateGUID();
            const name = `${node.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.${format.toLowerCase()}`;

            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    if (this.pendingUploads.has(id)) {
                        this.pendingUploads.delete(id);
                        console.warn(`[F2E] Upload timeout for ${name}`);
                        resolve(null);
                    }
                }, 30000);

                this.pendingUploads.set(id, (result: any) => {
                    clearTimeout(timeout);
                    if (result.success) {
                        resolve(result.url);
                    } else {
                        console.warn(`[F2E] Upload failed for ${name}: ${result.error}`);
                        resolve(null);
                    }
                });

                figma.ui.postMessage({
                    type: 'upload-image-request',
                    id,
                    name,
                    mimeType,
                    data: bytes
                });
            });

        } catch (e) {
            console.error('Error preparing upload:', e);
            return null;
        }
    }

    async compile(nodes: readonly SceneNode[]): Promise<ElementorElement[]> {
        const elements = await Promise.all(
            Array.from(nodes).map(async node => {
                const element = await this.processNode(node);
                if (element.elType === 'widget' && element.widgetType === 'container') {
                    element.elType = 'container';
                    element.isInner = false;
                    delete element.widgetType;
                }
                return element;
            })
        );
        return elements;
    }

    async processNode(node: SceneNode): Promise<ElementorElement> {
        const name = node.name.toLowerCase();
        const widgetPrefix = 'w:';

        if (name.startsWith(widgetPrefix)) {
            const widgetSlug = name.substring(widgetPrefix.length).split(' ')[0].trim();
            if (widgetSlug) {
                if (['container', 'section', 'image-box', 'icon-box', 'image-box-card'].includes(widgetSlug)) {
                    return this.createContainer(node);
                }
                return this.createExplicitWidget(node, widgetSlug);
            }
        }

        if (node.type === 'TEXT') {
            return createTextWidget(node as TextNode);
        }

        if (
            node.type === 'FRAME' ||
            node.type === 'INSTANCE' ||
            node.type === 'COMPONENT' ||
            node.type === 'GROUP'
        ) {
            return this.createContainer(node);
        }

        if (['VECTOR', 'STAR', 'ELLIPSE', 'POLYGON', 'BOOLEAN_OPERATION', 'LINE'].includes(node.type)) {
            return this.createExplicitWidget(node, 'icon');
        }

        if (node.type === 'RECTANGLE') {
            return this.createExplicitWidget(node, 'image');
        }

        const settings = {
            editor: `Unsupported node type: ${node.type}. Please wrap it in a frame and name it with a 'w:' prefix if you want to export it.`
        };
        return {
            id: generateGUID(),
            elType: 'widget',
            widgetType: 'text-editor',
            settings,
            elements: []
        };
    }

    async createContainer(node: SceneNode): Promise<ElementorElement> {
        const settings: ElementorSettings = {};
        Object.assign(settings, extractBorderStyles(node));
        Object.assign(settings, extractShadows(node));
        Object.assign(settings, extractBackgroundAdvanced(node));
        Object.assign(settings, extractPadding(node));
        Object.assign(settings, extractDimensions(node));
        Object.assign(settings, extractOpacity(node));
        Object.assign(settings, extractTransform(node));
        Object.assign(settings, extractInnerShadow(node));
        Object.assign(settings, extractBlendMode(node));
        Object.assign(settings, extractCSSFilters(node));
        Object.assign(settings, extractOverflow(node));
        Object.assign(settings, extractPositioning(node));
        Object.assign(settings, extractCustomCSS(node));
        Object.assign(settings, extractFlexLayout(node));

        if ('width' in node && (node as any).width > 800) {
            const anyNode: any = node;
            if (
                'primaryAxisAlignItems' in anyNode &&
                (anyNode.primaryAxisAlignItems === 'CENTER' ||
                    anyNode.counterAxisAlignItems === 'CENTER')
            ) {
                settings.content_width = 'boxed';
            }
        }

        if (settings._position === 'absolute') {
            delete settings._position;
            delete settings._offset_x;
            delete settings._offset_y;
        }

        let childElements: ElementorElement[] = [];
        if ('children' in node) {
            childElements = await Promise.all(
                (node as FrameNode).children.map(child => this.processNode(child))
            );
        }

        return {
            id: generateGUID(),
            elType: 'container',
            settings,
            elements: childElements
        };
    }

    async createExplicitWidget(node: SceneNode, widgetSlug: string): Promise<ElementorElement> {
        console.log(`[F2E Debug] Processing widget: ${widgetSlug} for node: ${node.name} (${node.id})`);
        const settings: ElementorSettings = {};

        if (widgetSlug === 'button') {
            let textNode: TextNode | null = null;
            let bgNode: GeometryNode | null = null;
            let iconNode: SceneNode | null = null;

            if (node.type === 'TEXT') {
                textNode = node as TextNode;
            } else if ('children' in node) {
                const frame = node as FrameNode;
                textNode = frame.children.find(c => c.type === 'TEXT') as TextNode | null;

                // Procurar ícone
                iconNode = frame.children.find(c =>
                    ['VECTOR', 'STAR', 'ELLIPSE', 'POLYGON', 'BOOLEAN_OPERATION', 'LINE'].includes(c.type)
                ) || null;

                if (hasFills(frame) && frame.fills !== figma.mixed && (frame.fills as any[]).length > 0) {
                    bgNode = frame as any;
                } else {
                    bgNode = frame.children.find(
                        c =>
                            (c.type === 'RECTANGLE' || c.type === 'FRAME') &&
                            hasFills(c as any)
                    ) as GeometryNode | null;
                }
            }

            // Texto do botão
            if (textNode) {
                settings.text = textNode.characters;
                settings.typography_typography = 'custom';
                const typo = extractTypography(textNode);
                Object.assign(settings, typo);
                const textColor = extractTextColor(textNode);
                if (textColor) settings.button_text_color = textColor;
            } else {
                settings.text = 'Click Here';
            }

            // Background
            if (bgNode || (hasFills(node) && node.type !== 'TEXT')) {
                const bgSource = (bgNode || (node as GeometryNode)) as SceneNode;
                const bgStyles = extractBackgroundAdvanced(bgSource);
                if (bgStyles.background_color) {
                    settings.button_background_color = bgStyles.background_color;
                }
            }

            // Ícone
            if (iconNode) {
                const iconUrl = await this.uploadImageToWordPress(iconNode, 'SVG');
                if (iconUrl) {
                    settings.selected_icon = {
                        value: { url: iconUrl, id: 0, source: 'library' },
                        library: 'svg'
                    };
                } else {
                    const svgBytes = await exportNodeAsSvg(iconNode);
                    if (svgBytes) {
                        settings.selected_icon = {
                            value: { url: `data:image/svg+xml;base64,${figma.base64Encode(svgBytes)}` },
                            library: 'svg'
                        };
                    } else {
                        settings.selected_icon = { value: 'fas fa-arrow-right', library: 'fa-solid' };
                    }
                }
                settings.icon_align = 'right';
                settings.icon_indent = { unit: 'px', size: 10 };
            }

            // Size baseado na altura
            if ('height' in node) {
                const height = (node as any).height;
                if (height < 30) settings.size = 'xs';
                else if (height < 40) settings.size = 'sm';
                else if (height < 50) settings.size = 'md';
                else if (height < 60) settings.size = 'lg';
                else settings.size = 'xl';
            } else {
                settings.size = 'md';
            }

            settings.align = 'left';
            settings.link = { url: '#', is_external: false, nofollow: false };

            // Hover (cores padrão)
            if (settings.button_text_color) {
                settings.hover_color = settings.button_text_color;
            }
            if (settings.button_background_color) {
                settings.button_background_hover_color = settings.button_background_color;
            }
        }
        else if (widgetSlug === 'icon') {
            const url = await this.uploadImageToWordPress(node, 'SVG');

            if (url) {
                settings.selected_icon = {
                    value: { url, id: 0, source: 'library' },
                    library: 'svg'
                };
            } else {
                let svgBytes = await exportNodeAsSvg(node);
                if (svgBytes) {
                    settings.selected_icon = {
                        value: { url: `data:image/svg+xml;base64,${figma.base64Encode(svgBytes)}` },
                        library: 'svg'
                    };
                } else {
                    settings.selected_icon = { value: 'fas fa-star', library: 'fa-solid' };
                }
            }

            if (hasFills(node) && Array.isArray(node.fills) && node.fills.length > 0) {
                const fill = node.fills[0];
                if (fill.type === 'SOLID') {
                    settings.primary_color = convertColor(fill);
                }
            }
        }
        else if (widgetSlug === 'icon-box') {
            let iconNode: SceneNode | null = null;
            let titleNode: TextNode | null = null;
            let descNode: TextNode | null = null;

            // Find children
            if ('children' in node) {
                const frame = node as FrameNode;
                // Find Icon (Vector-like or Image)
                iconNode = frame.children.find(c =>
                    ['VECTOR', 'STAR', 'ELLIPSE', 'POLYGON', 'BOOLEAN_OPERATION', 'LINE'].includes(c.type) ||
                    (c.type === 'INSTANCE' || c.type === 'FRAME') && c.name.toLowerCase().includes('icon')
                ) || null;

                // Find Texts
                const textNodes = frame.children.filter(c => c.type === 'TEXT') as TextNode[];
                if (textNodes.length > 0) titleNode = textNodes[0];
                if (textNodes.length > 1) descNode = textNodes[1];
            }

            // Handle Icon
            if (iconNode) {
                const url = await this.uploadImageToWordPress(iconNode, 'SVG');
                if (url) {
                    settings.selected_icon = {
                        value: { url, id: 0, source: 'library' },
                        library: 'svg'
                    };
                } else {
                    let svgBytes = await exportNodeAsSvg(iconNode);
                    if (svgBytes) {
                        settings.selected_icon = {
                            value: { url: `data:image/svg+xml;base64,${figma.base64Encode(svgBytes)}` },
                            library: 'svg'
                        };
                    } else {
                        settings.selected_icon = { value: 'fas fa-star', library: 'fa-solid' };
                    }
                }

                // Icon Color
                if (hasFills(iconNode) && Array.isArray(iconNode.fills) && iconNode.fills.length > 0) {
                    const fill = iconNode.fills[0];
                    if (fill.type === 'SOLID') {
                        settings.primary_color = convertColor(fill);
                    }
                }
            }

            // Handle Title
            if (titleNode) {
                settings.title_text = titleNode.characters;
                const typo = extractTypography(titleNode);
                const color = extractTextColor(titleNode);

                // Map typography to title_typography
                for (const key in typo) {
                    const newKey = key.replace('typography_', 'title_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
                if (color) settings.title_color = color;
            } else {
                settings.title_text = 'This is the heading';
            }

            // Handle Description
            if (descNode) {
                settings.description_text = descNode.characters;
                const typo = extractTypography(descNode);
                const color = extractTextColor(descNode);

                // Map typography to description_typography
                for (const key in typo) {
                    const newKey = key.replace('typography_', 'description_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
                if (color) settings.description_color = color;
            } else {
                settings.description_text = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';
            }

            // View (Default, Stacked, Framed) - simplified to default for now
            settings.view = 'default';
        }
        else if (widgetSlug === 'image-box') {
            console.log(`[F2E] Processing image-box: ${node.name}`);
            let imageNode: SceneNode | null = null;
            let titleNode: TextNode | null = null;
            let descNode: TextNode | null = null;

            // Find children
            if ('children' in node) {
                const frame = node as FrameNode;
                console.log(`[F2E] image-box has ${frame.children.length} children`);

                // Find Image (Rectangle, Frame, or Instance with image fill or named w:image)
                imageNode = frame.children.find(c => {
                    const isNamedImage = c.name.toLowerCase().includes('w:image') || c.name.toLowerCase().includes('image');
                    const isImageType = ['RECTANGLE', 'FRAME', 'INSTANCE', 'COMPONENT'].includes(c.type);

                    // Check for image fill (only for geometry nodes)
                    let hasImageFillCheck = false;
                    if ('fills' in c && c.fills !== figma.mixed && Array.isArray(c.fills)) {
                        hasImageFillCheck = c.fills.some((fill: any) => fill.type === 'IMAGE');
                    }

                    console.log(`[F2E]   Child "${c.name}" (${c.type}): isNamed=${isNamedImage}, hasImage=${hasImageFillCheck}, isType=${isImageType}`);

                    return isNamedImage || (isImageType && hasImageFillCheck);
                }) || null;

                // Find Texts
                const textNodes = frame.children.filter(c => c.type === 'TEXT') as TextNode[];
                console.log(`[F2E] Found ${textNodes.length} text nodes`);
                if (textNodes.length > 0) titleNode = textNodes[0];
                if (textNodes.length > 1) descNode = textNodes[1];
            }

            // Handle Image
            if (imageNode) {
                console.log(`[F2E] Found image node: ${imageNode.name}`);
                const url = await this.uploadImageToWordPress(imageNode, 'PNG');
                if (url) {
                    console.log(`[F2E] Image uploaded successfully: ${url}`);
                    settings.image = { url, id: 0 };
                    console.log(`[F2E] ✅ Final image URL in JSON:`, url.substring(0, 100) + '...');
                } else {
                    console.warn(`[F2E] Image upload failed, using PNG base64`);
                    const pngBytes = await exportNodeAsPng(imageNode);
                    if (pngBytes) {
                        const base64Url = `data:image/png;base64,${figma.base64Encode(pngBytes)}`;
                        settings.image = {
                            url: base64Url
                        };
                        console.log(`[F2E] ⚠️ Using base64 fallback (${base64Url.length} chars)`);
                    } else {
                        settings.image = { url: '' };
                        console.error(`[F2E] ❌ Failed to export image as PNG`);
                    }
                }
            } else {
                console.warn(`[F2E] No image node found in image-box: ${node.name}`);
                settings.image = { url: '' };
            }

            // Handle Title
            if (titleNode) {
                settings.title_text = titleNode.characters;
                const typo = extractTypography(titleNode);
                const color = extractTextColor(titleNode);

                // Map typography to title_typography
                for (const key in typo) {
                    const newKey = key.replace('typography_', 'title_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
                if (color) settings.title_color = color;
            } else {
                settings.title_text = 'This is the heading';
            }

            // Handle Description
            if (descNode) {
                settings.description_text = descNode.characters;
                const typo = extractTypography(descNode);
                const color = extractTextColor(descNode);

                // Map typography to description_typography
                for (const key in typo) {
                    const newKey = key.replace('typography_', 'description_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
                if (color) settings.description_color = color;
            } else {
                settings.description_text = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';
            }

            // Image position (top, left, right)
            settings.image_position = 'top';
            settings.title_size = 'default';
            settings.link = { url: '#', is_external: false, nofollow: false };
        }


        else if (widgetSlug === 'heading') {
            let textNode: TextNode | null = null;

            if (node.type === 'TEXT') {
                textNode = node as TextNode;
            } else if ('children' in node) {
                const frame = node as FrameNode;
                textNode = frame.children.find(c => c.type === 'TEXT') as TextNode | null;
            }

            if (textNode) {
                settings.title = textNode.characters;
                const typo = extractTypography(textNode);
                const color = extractTextColor(textNode);

                Object.assign(settings, typo);
                if (color) settings.title_color = color;

                // Detectar tag HTML baseado no tamanho da fonte
                const fontSize = typo.typography_font_size?.size || 32;
                if (fontSize >= 48) settings.header_size = 'h1';
                else if (fontSize >= 36) settings.header_size = 'h2';
                else if (fontSize >= 28) settings.header_size = 'h3';
                else if (fontSize >= 24) settings.header_size = 'h4';
                else if (fontSize >= 20) settings.header_size = 'h5';
                else settings.header_size = 'h6';
            } else {
                settings.title = 'Your Title Here';
                settings.header_size = 'h2';
            }

            settings.align = 'left';
        }
        else if (widgetSlug === 'text-editor') {
            let textNode: TextNode | null = null;

            if (node.type === 'TEXT') {
                textNode = node as TextNode;
            } else if ('children' in node) {
                const frame = node as FrameNode;
                textNode = frame.children.find(c => c.type === 'TEXT') as TextNode | null;
            }

            if (textNode) {
                // Converter para HTML básico
                const text = textNode.characters;
                settings.editor = `<p>${text.replace(/\n/g, '</p><p>')}</p>`;

                const typo = extractTypography(textNode);
                const color = extractTextColor(textNode);

                Object.assign(settings, typo);
                if (color) settings.text_color = color;
            } else {
                settings.editor = '<p>Your text here...</p>';
            }

            settings.align = 'left';
            settings.text_columns = 1;
            settings.column_gap = { unit: 'px', size: 20 };
        }
        else if (widgetSlug === 'divider') {
            settings.style = 'solid';
            settings.weight = { unit: 'px', size: 1 };
            settings.width = { unit: '%', size: 100 };
            settings.align = 'center';
            settings.gap = { unit: 'px', size: 15 };
            settings.look = 'line';

            // Extrair cor da borda se houver
            const borderStyles = extractBorderStyles(node);
            if (borderStyles.border_color) {
                settings.color = borderStyles.border_color;
            } else {
                settings.color = 'rgba(0, 0, 0, 0.1)';
            }
        }
        else if (widgetSlug === 'spacer') {
            // Extrair altura do node
            let spaceSize = 50;
            if ('height' in node) {
                spaceSize = Math.round((node as any).height);
            }

            settings.space = { unit: 'px', size: spaceSize };
            settings.space_tablet = { unit: 'px', size: Math.round(spaceSize * 0.6) };
            settings.space_mobile = { unit: 'px', size: Math.round(spaceSize * 0.4) };
        }
        else if (widgetSlug === 'image') {
            const url = await this.uploadImageToWordPress(node, 'PNG');

            if (url) {
                settings.image = {
                    url,
                    id: 0,
                    size: 'full',
                    source: 'library'
                };
            } else {
                let pngBytes = await exportNodeAsPng(node);
                if (pngBytes) {
                    settings.image = {
                        url: `data:image/png;base64,${figma.base64Encode(pngBytes)}`
                    };
                } else {
                    settings.image = {
                        url: 'https://via.placeholder.com/800x600?text=Upload+Failed'
                    };
                }
            }

            // Image settings
            settings.image_size = 'full';
            settings.align = 'center';
            settings.caption_source = 'none';
            settings.link_to = 'none';
            settings.open_lightbox = 'default';

            // Dimensões
            if ('width' in node && 'height' in node) {
                const nodeWidth = (node as any).width;
                const nodeHeight = (node as any).height;

                settings.width = { unit: 'px', size: Math.round(nodeWidth) };
                settings.height = 'auto';
                settings.object_fit = 'cover';
            }

            // CSS Filters (aplicados automaticamente no final)
        }
        else if (widgetSlug === 'video') {
            settings.video_type = 'youtube';
            settings.youtube_url = 'https://www.youtube.com/watch?v=XHOmBV4js_E';
            settings.aspect_ratio = '169';
            settings.autoplay = 'no';
            settings.mute = 'no';
        }
        else if (widgetSlug === 'alert') {
            let titleNode: TextNode | null = null;
            let descNode: TextNode | null = null;

            if ('children' in node) {
                const frame = node as FrameNode;
                const textNodes = frame.children.filter(c => c.type === 'TEXT') as TextNode[];
                if (textNodes.length > 0) titleNode = textNodes[0];
                if (textNodes.length > 1) descNode = textNodes[1];
            }

            settings.alert_type = 'info';
            settings.alert_title = titleNode ? titleNode.characters : 'Atenção!';
            settings.alert_description = descNode ? descNode.characters : 'Mensagem informativa.';
            settings.show_dismiss = 'yes';
        }
        else if (widgetSlug === 'counter') {
            let numberNode: TextNode | null = null;
            let titleNode: TextNode | null = null;

            if ('children' in node) {
                const frame = node as FrameNode;
                const textNodes = frame.children.filter(c => c.type === 'TEXT') as TextNode[];
                if (textNodes.length > 0) numberNode = textNodes[0];
                if (textNodes.length > 1) titleNode = textNodes[1];
            }

            const numberText = numberNode ? numberNode.characters : '100';
            settings.starting_number = 0;
            settings.ending_number = parseInt(numberText.replace(/\D/g, '')) || 100;
            settings.duration = 2000;
            settings.thousand_separator = ',';
            settings.title = titleNode ? titleNode.characters : 'Título';

            if (numberNode) {
                const typo = extractTypography(numberNode);
                const color = extractTextColor(numberNode);
                for (const key in typo) {
                    const newKey = key.replace('typography_', 'number_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
                if (color) settings.number_color = color;
            }

            if (titleNode) {
                const typo = extractTypography(titleNode);
                const color = extractTextColor(titleNode);
                for (const key in typo) {
                    const newKey = key.replace('typography_', 'title_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
                if (color) settings.title_color = color;
            }
        }
        else if (widgetSlug === 'progress') {
            let titleNode: TextNode | null = null;

            if ('children' in node) {
                const frame = node as FrameNode;
                titleNode = frame.children.find(c => c.type === 'TEXT') as TextNode | null;
            }

            settings.title = titleNode ? titleNode.characters : 'Progresso';
            settings.percent = { unit: '%', size: 70 };
            settings.inner_text = 'yes';
            settings.display_percentage = 'show';

            // Cor da barra baseada no background
            const bgStyles = extractBackgroundAdvanced(node);
            if (bgStyles.background_color) {
                settings.progress_color = bgStyles.background_color;
            }
        }
        else if (widgetSlug === 'accordion') {
            const items: any[] = [];

            if ('children' in node) {
                const frame = node as FrameNode;
                for (const child of frame.children) {
                    if (!('children' in child)) continue;

                    const itemFrame = child as FrameNode;
                    const textNodes = itemFrame.children.filter(c => c.type === 'TEXT') as TextNode[];

                    items.push({
                        tab_title: textNodes[0]?.characters || 'Título do Acordeão',
                        tab_content: textNodes[1]?.characters || 'Conteúdo do acordeão.',
                        _id: generateGUID().substring(0, 7)
                    });
                }
            }

            settings.tabs = items.length > 0 ? items : [
                { tab_title: 'Título 1', tab_content: 'Conteúdo 1', _id: generateGUID().substring(0, 7) }
            ];
            settings.selected_item = '1';
        }
        else if (widgetSlug === 'tabs') {
            const items: any[] = [];

            if ('children' in node) {
                const frame = node as FrameNode;
                for (const child of frame.children) {
                    if (!('children' in child)) continue;

                    const itemFrame = child as FrameNode;
                    const textNodes = itemFrame.children.filter(c => c.type === 'TEXT') as TextNode[];

                    items.push({
                        tab_title: textNodes[0]?.characters || 'Tab',
                        tab_content: textNodes[1]?.characters || 'Conteúdo da tab.',
                        _id: generateGUID().substring(0, 7)
                    });
                }
            }

            settings.tabs = items.length > 0 ? items : [
                { tab_title: 'Tab 1', tab_content: 'Conteúdo 1', _id: generateGUID().substring(0, 7) }
            ];
            settings.type = 'horizontal';
        }
        else if (widgetSlug === 'basic-gallery' || widgetSlug === 'gallery') {
            const galleryImages: any[] = [];

            if ('children' in node) {
                const frame = node as FrameNode;
                for (const child of frame.children) {
                    if (child.type === 'RECTANGLE' || (hasFills(child) && child.type !== 'TEXT')) {
                        const url = await this.uploadImageToWordPress(child, 'PNG');
                        if (url) {
                            galleryImages.push({ id: 0, url });
                        }
                    }
                }
            }

            settings.gallery = galleryImages.length > 0 ? galleryImages : [];
            settings.gallery_layout = 'grid';
            settings.columns = 3;
            settings.image_size = 'medium';
            settings.gap = { unit: 'px', size: 10 };
        }
        else if (widgetSlug === 'soundcloud') {
            settings.url = 'https://soundcloud.com/';
            settings.visual = 'yes';
            settings.auto_play = 'no';
        }
        else if (widgetSlug === 'google-maps' || widgetSlug === 'google_maps') {
            settings.address = 'São Paulo, Brasil';
            settings.zoom = { size: 10 };
            settings.height = { unit: 'px', size: 300 };
        }
        else if (widgetSlug === 'html') {
            let textNode: TextNode | null = null;

            if (node.type === 'TEXT') {
                textNode = node as TextNode;
            } else if ('children' in node) {
                const frame = node as FrameNode;
                textNode = frame.children.find(c => c.type === 'TEXT') as TextNode | null;
            }

            settings.html = textNode ? textNode.characters : '<!-- HTML personalizado -->';
        }
        else if (widgetSlug === 'shortcode') {
            let textNode: TextNode | null = null;

            if (node.type === 'TEXT') {
                textNode = node as TextNode;
            } else if ('children' in node) {
                const frame = node as FrameNode;
                textNode = frame.children.find(c => c.type === 'TEXT') as TextNode | null;
            }

            settings.shortcode = textNode ? textNode.characters : '[seu_shortcode]';
        }
        else {
            const textChildren: TextNode[] = [];
            if ('children' in node) {
                const frame = node as FrameNode;
                frame.children.forEach(c => {
                    if (c.type === 'TEXT') textChildren.push(c as TextNode);
                });
            } else if (node.type === 'TEXT') {
                textChildren.push(node as TextNode);
            }

            if (textChildren.length > 0) {
                const titleNode = textChildren[0];
                settings.title = titleNode.characters;
                settings.title_text = titleNode.characters;
                settings.heading = titleNode.characters;
                const typo = extractTypography(titleNode);
                const color = extractTextColor(titleNode);
                Object.assign(settings, typo);
                if (color) settings.title_color = color;

                for (const key in typo) {
                    const newKey = key.replace('typography_', 'title_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
            }
            if (textChildren.length > 1) {
                const descNode = textChildren[1];
                settings.description_text = descNode.characters;
                const typo = extractTypography(descNode);
                const color = extractTextColor(descNode);
                Object.assign(settings, typo);
                if (color) settings.description_color = color;
                for (const key in typo) {
                    const newKey = key.replace('typography_', 'description_typography_');
                    (settings as any)[newKey] = (typo as any)[key];
                }
            }
        }

        Object.assign(settings, extractBorderStyles(node));
        Object.assign(settings, extractShadows(node));
        Object.assign(settings, extractBackgroundAdvanced(node));
        Object.assign(settings, extractPadding(node));
        Object.assign(settings, extractOpacity(node));
        Object.assign(settings, extractTransform(node));
        Object.assign(settings, extractInnerShadow(node));
        Object.assign(settings, extractBlendMode(node));
        Object.assign(settings, extractCSSFilters(node));
        Object.assign(settings, extractOverflow(node));
        Object.assign(settings, extractPositioning(node));
        Object.assign(settings, extractCustomCSS(node));

        return {
            id: generateGUID(),
            elType: 'widget',
            widgetType: widgetSlug,
            settings,
            elements: []
        };
    }

    debugNodeRecursive(node: SceneNode, depth: number): any {
        if (depth > 5) return { type: node.type, id: node.id, note: 'Max depth reached' };
        const info: any = { id: node.id, type: node.type, name: node.name };
        if ('children' in node) {
            info.children = (node as FrameNode).children.map(c =>
                this.debugNodeRecursive(c, depth + 1)
            );
        }
        if (node.type === 'TEXT') {
            info.typography = extractTypography(node as TextNode);
        }
        info.margin = extractMargin(node);
        info.positioning = extractPositioning(node);
        info.background = extractBackgroundAdvanced(node);
        return info;
    }
}

// -------------------- Main Execution --------------------
figma.showUI(__html__, { width: 400, height: 600 });

// We need a global instance to handle the message callbacks
let compiler: ElementorCompiler;

// Load saved WP config and initialize compiler
figma.clientStorage.getAsync('wp_config').then(config => {
    compiler = new ElementorCompiler(config || {});
    if (config) {
        figma.ui.postMessage({ type: 'load-wp-config', config });
    }
});


figma.ui.onmessage = async (msg) => {
    // Ensure compiler is initialized before processing messages
    if (!compiler) {
        console.warn('Compiler not yet initialized. Message deferred or ignored.');
        return;
    }

    if (msg.type === 'export-elementor') {
        const selection = figma.currentPage.selection;
        if (selection.length === 0) {
            figma.notify('Selecione pelo menos um frame para exportar.');
            return;
        }

        figma.notify('Gerando JSON... (Isso pode demorar se houver uploads)');

        try {
            const elements = await compiler.compile(selection);

            const template: ElementorTemplate = {
                type: 'elementor',
                siteurl: compiler.wpConfig?.url || '',
                elements,
                version: '0.4'
            };

            figma.ui.postMessage({ type: 'export-result', data: JSON.stringify(template, null, 2) });
            figma.notify('JSON gerado! Copie e cole no Elementor (Ctrl+V).');
        } catch (e) {
            console.error(e);
            figma.notify('Erro na exportação. Verifique o console.');
        }
    } else if (msg.type === 'rename-layer') {
        const selection = figma.currentPage.selection;
        if (selection.length === 1) {
            selection[0].name = msg.newName;
            figma.notify(`Camada renomeada para: ${msg.newName}`);
        } else {
            figma.notify('Selecione apenas uma camada para renomear.');
        }
    } else if (msg.type === 'create-component') {
        // ... (Create component logic if needed, or keep existing)
        figma.notify('Inserção de componentes ainda não implementada.');
    } else if (msg.type === 'resize-window') {
        figma.ui.resize(msg.width, msg.height);
    } else if (msg.type === 'debug-structure') {
        const selection = figma.currentPage.selection;
        if (selection.length === 0) return;

        const debugData = selection.map(node => ({
            name: node.name,
            type: node.type,
            id: node.id,
            children: 'children' in node ? (node as FrameNode).children.length : 0
        }));

        figma.ui.postMessage({ type: 'debug-result', data: JSON.stringify(debugData, null, 2) });
    } else if (msg.type === 'upload-image-response') {
        const resolver = compiler.pendingUploads.get(msg.id);
        if (resolver) {
            resolver(msg);
            compiler.pendingUploads.delete(msg.id);
        }
    } else if (msg.type === 'save-wp-config') {
        await figma.clientStorage.setAsync('wp_config', msg.config);
        compiler.wpConfig = msg.config; // Update compiler's config
        figma.notify('Configuração WP salva!');
    }
};
