// Elementor JSON Compiler Logic - Version 3.4 (Propriedades Completas - Fase 1)

function generateGUID() {
    return 'xxxxxxxxxx'.replace(/[x]/g, function () {
        return ((Math.random() * 36) | 0).toString(36);
    });
}

function convertColor(paint) {
    if (!paint || paint.type !== 'SOLID') return '';
    var r = paint.color.r;
    var g = paint.color.g;
    var b = paint.color.b;
    var a = (paint.opacity !== undefined && paint.opacity !== null) ? paint.opacity : 1;
    return 'rgba(' + Math.round(r * 255) + ', ' + Math.round(g * 255) + ', ' + Math.round(b * 255) + ', ' + a + ')';
}

function convertColorToHex(paint) {
    if (!paint || paint.type !== 'SOLID') return '';
    var r = Math.round(paint.color.r * 255);
    var g = Math.round(paint.color.g * 255);
    var b = Math.round(paint.color.b * 255);
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
}

function isVisible(node) {
    return node.visible !== false;
}

// Extrai estilos de tipografia completos
function extractTypography(node) {
    var typo = {};

    if (node.type !== 'TEXT') return typo;

    // Tamanho da fonte
    if (node.fontSize) {
        typo.typography_font_size = { unit: 'px', size: Math.round(node.fontSize) };
    }

    // Peso da fonte
    if (node.fontName && node.fontName.style) {
        var style = node.fontName.style.toLowerCase();
        if (style.includes('bold')) typo.typography_font_weight = '700';
        else if (style.includes('semibold')) typo.typography_font_weight = '600';
        else if (style.includes('medium')) typo.typography_font_weight = '500';
        else if (style.includes('light')) typo.typography_font_weight = '300';
        else typo.typography_font_weight = '400';

        // Estilo itálico
        if (style.includes('italic')) typo.typography_font_style = 'italic';
    }

    // Família da fonte
    if (node.fontName && node.fontName.family) {
        typo.typography_font_family = node.fontName.family;
    }

    // Altura da linha
    if (node.lineHeight && node.lineHeight.value) {
        if (node.lineHeight.unit === 'PIXELS') {
            typo.typography_line_height = { unit: 'px', size: Math.round(node.lineHeight.value) };
        } else if (node.lineHeight.unit === 'PERCENT') {
            typo.typography_line_height = { unit: 'em', size: (node.lineHeight.value / 100).toFixed(2) };
        }
    }

    // Espaçamento entre letras
    if (node.letterSpacing && node.letterSpacing.value) {
        typo.typography_letter_spacing = { unit: 'px', size: node.letterSpacing.value };
    }

    // Alinhamento de texto
    if (node.textAlignHorizontal) {
        if (node.textAlignHorizontal === 'LEFT') typo.align = 'left';
        else if (node.textAlignHorizontal === 'CENTER') typo.align = 'center';
        else if (node.textAlignHorizontal === 'RIGHT') typo.align = 'right';
        else if (node.textAlignHorizontal === 'JUSTIFIED') typo.align = 'justify';
    }

    // Decoração de texto
    if (node.textDecoration) {
        if (node.textDecoration === 'UNDERLINE') typo.typography_text_decoration = 'underline';
        else if (node.textDecoration === 'STRIKETHROUGH') typo.typography_text_decoration = 'line-through';
    }

    // Transformação de texto
    if (node.textCase) {
        if (node.textCase === 'UPPER') typo.typography_text_transform = 'uppercase';
        else if (node.textCase === 'LOWER') typo.typography_text_transform = 'lowercase';
        else if (node.textCase === 'TITLE') typo.typography_text_transform = 'capitalize';
    }

    return typo;
}

// Extrai cores de texto
function extractTextColor(node) {
    if (node.type !== 'TEXT') return '';
    if (!node.fills || !Array.isArray(node.fills) || node.fills.length === 0) return '';
    return convertColor(node.fills[0]);
}

// Extrai estilos de borda (CORRIGIDO - sempre extrai border-radius)
function extractBorderStyles(node) {
    var border = {};

    // Cor e largura da borda (apenas se houver strokes)
    if (node.strokes && Array.isArray(node.strokes) && node.strokes.length > 0) {
        border.border_color = convertColor(node.strokes[0]);

        if (node.strokeWeight) {
            border.border_width = { unit: 'px', top: node.strokeWeight, right: node.strokeWeight, bottom: node.strokeWeight, left: node.strokeWeight, isLinked: true };
        }
    }

    // Raio da borda (SEMPRE extrair, mesmo sem strokes)
    if (node.cornerRadius !== undefined) {
        if (typeof node.cornerRadius === 'number') {
            border.border_radius = {
                unit: 'px',
                top: node.cornerRadius,
                right: node.cornerRadius,
                bottom: node.cornerRadius,
                left: node.cornerRadius,
                isLinked: true
            };
        } else if (node.topLeftRadius !== undefined) {
            border.border_radius = {
                unit: 'px',
                top: node.topLeftRadius || 0,
                right: node.topRightRadius || 0,
                bottom: node.bottomRightRadius || 0,
                left: node.bottomLeftRadius || 0,
                isLinked: false
            };
        }
    }

    return border;
}

// Extrai sombras (box-shadow)
function extractShadows(node) {
    if (!node.effects || !Array.isArray(node.effects) || node.effects.length === 0) return {};

    var shadows = [];
    node.effects.forEach(function (effect) {
        if (effect.type === 'DROP_SHADOW' && effect.visible !== false) {
            var color = effect.color;
            var rgba = 'rgba(' +
                Math.round(color.r * 255) + ', ' +
                Math.round(color.g * 255) + ', ' +
                Math.round(color.b * 255) + ', ' +
                (color.a || 1) + ')';

            shadows.push({
                horizontal: Math.round(effect.offset.x) + 'px',
                vertical: Math.round(effect.offset.y) + 'px',
                blur: Math.round(effect.radius) + 'px',
                spread: Math.round(effect.spread || 0) + 'px',
                color: rgba
            });
        }
    });

    if (shadows.length > 0) {
        return { box_shadow_box_shadow_type: 'yes', box_shadow_box_shadow: shadows[0] };
    }

    return {};
}

// Extrai opacidade (NOVO)
function extractOpacity(node) {
    if (node.opacity !== undefined && node.opacity !== 1) {
        return {
            _opacity: {
                unit: 'px',
                size: node.opacity
            }
        };
    }
    return {};
}

// Extrai text-shadow (NOVO)
function extractTextShadow(node) {
    if (node.type !== 'TEXT') return {};
    if (!node.effects || !Array.isArray(node.effects) || node.effects.length === 0) return {};

    var textShadows = [];
    node.effects.forEach(function (effect) {
        if (effect.type === 'DROP_SHADOW' && effect.visible !== false) {
            var color = effect.color;
            var rgba = 'rgba(' +
                Math.round(color.r * 255) + ', ' +
                Math.round(color.g * 255) + ', ' +
                Math.round(color.b * 255) + ', ' +
                (color.a || 1) + ')';

            textShadows.push({
                horizontal: Math.round(effect.offset.x) + 'px',
                vertical: Math.round(effect.offset.y) + 'px',
                blur: Math.round(effect.radius) + 'px',
                color: rgba
            });
        }
    });

    if (textShadows.length > 0) {
        return {
            text_shadow_text_shadow_type: 'yes',
            text_shadow_text_shadow: textShadows[0]
        };
    }

    return {};
}

// Extrai transformações (rotação) (NOVO)
function extractTransform(node) {
    var transform = {};

    // Rotação
    if (node.rotation !== undefined && node.rotation !== 0) {
        transform._transform_rotate_popover = 'custom';
        transform._transform_rotateZ_effect = {
            unit: 'deg',
            size: Math.round(node.rotation)
        };
    }

    return transform;
}

// Extrai padding
function extractPadding(node) {
    if (!node.paddingTop && !node.paddingLeft) return {};

    return {
        padding: {
            unit: 'px',
            top: node.paddingTop || 0,
            right: node.paddingRight || 0,
            bottom: node.paddingBottom || 0,
            left: node.paddingLeft || 0,
            isLinked: false
        }
    };
}

// Extrai dimensões
function extractDimensions(node) {
    var dims = {};

    if (node.width) {
        dims.width = { unit: 'px', size: Math.round(node.width) };
    }

    if (node.height) {
        dims.height = { unit: 'px', size: Math.round(node.height) };
    }

    return dims;
}

// Extrai cor de fundo
function extractBackgroundColor(node) {
    if (!node.fills || !Array.isArray(node.fills) || node.fills.length === 0) return {};

    var fill = node.fills[0];
    if (fill.type === 'SOLID') {
        return {
            background_background: 'classic',
            background_color: convertColor(fill)
        };
    } else if (fill.type === 'IMAGE') {
        return {
            background_background: 'classic',
            background_image: { url: 'https://via.placeholder.com/800' },
            background_position: 'center center',
            background_size: 'cover'
        };
    } else if (fill.type === 'GRADIENT_LINEAR' || fill.type === 'GRADIENT_RADIAL') {
        // Gradientes são complexos, por enquanto usar cor sólida da primeira parada
        if (fill.gradientStops && fill.gradientStops.length > 0) {
            return {
                background_background: 'classic',
                background_color: convertColor({ type: 'SOLID', color: fill.gradientStops[0].color, opacity: fill.gradientStops[0].color.a })
            };
        }
    }

    return {};
}

class ElementorCompiler {
    constructor(config) {
        this.config = config || {};

        // --- WIDGET PRESETS LIBRARY ---
        this.widgetPresets = {
            // Basic & General
            'heading': { widgetType: 'heading', settings: { title: 'Heading' } },
            'image': { widgetType: 'image', settings: { image: { url: 'https://via.placeholder.com/800' } } },
            'text-editor': { widgetType: 'text-editor', settings: { editor: 'Lorem ipsum dolor sit amet.' } },
            'video': { widgetType: 'video', settings: { youtube_url: 'https://www.youtube.com/watch?v=XHOmBV4js_E' } },
            'button': { widgetType: 'button', settings: { text: 'Click Me' } },
            'divider': { widgetType: 'divider', settings: {} },
            'spacer': { widgetType: 'spacer', settings: { space: { size: 50, unit: 'px' } } },
            'google-maps': { widgetType: 'google_maps', settings: {} },
            'icon': { widgetType: 'icon', settings: { selected_icon: { value: 'fas fa-star', library: 'fa-solid' } } },

            // General (Free)
            'image-box': { widgetType: 'image-box', settings: { title_text: 'Title', description_text: 'Description' } },
            'icon-box': { widgetType: 'icon-box', settings: { title_text: 'Title', description_text: 'Description' } },
            'star-rating': { widgetType: 'star-rating', settings: {} },
            'image-carousel': { widgetType: 'image-carousel', settings: { gallery: [] } },
            'gallery': { widgetType: 'gallery', settings: { gallery: [], gallery_columns: { size: 3 } } },
            'icon-list': { widgetType: 'icon-list', settings: { icon_list: [{ text: 'List Item #1' }, { text: 'List Item #2' }] } },
            'counter': { widgetType: 'counter', settings: { starting_number: 0, ending_number: 100 } },
            'progress': { widgetType: 'progress', settings: { percent: { size: 50 } } },
            'testimonial': { widgetType: 'testimonial', settings: { testimonial_content: 'Great service!', testimonial_name: 'John Doe' } },
            'tabs': { widgetType: 'tabs', settings: { tabs: [{ tab_title: 'Tab #1', tab_content: 'Content #1' }, { tab_title: 'Tab #2', tab_content: 'Content #2' }] } },
            'accordion': { widgetType: 'accordion', settings: { tabs: [{ tab_title: 'Item #1', tab_content: 'Content #1' }] } },
            'toggle': { widgetType: 'toggle', settings: { tabs: [{ tab_title: 'Item #1', tab_content: 'Content #1' }] } },
            'social-icons': { widgetType: 'social-icons', settings: { social_icon_list: [{ social_icon: { value: 'fab fa-facebook', library: 'fa-brands' } }, { social_icon: { value: 'fab fa-twitter', library: 'fa-brands' } }] } },
            'alert': { widgetType: 'alert', settings: { alert_title: 'Alert', alert_description: 'This is an alert.' } },
            'soundcloud': { widgetType: 'soundcloud', settings: {} },
            'shortcode': { widgetType: 'shortcode', settings: { shortcode: '[shortcode]' } },
            'html': { widgetType: 'html', settings: { html: '<div>Code</div>' } },
            'menu-anchor': { widgetType: 'menu-anchor', settings: {} },
            'read-more': { widgetType: 'read-more', settings: {} },

            // Pro - Marketing & Conversion
            'form': { widgetType: 'form', settings: { form_name: 'New Form', button_text: 'Send' } },
            'login': { widgetType: 'login', settings: {} },
            'countdown': { widgetType: 'countdown', settings: { due_date: '2030-01-01 12:00' } },
            'call-to-action': { widgetType: 'call-to-action', settings: { title: 'CTA Title', description: 'Click the button below.', button_text: 'Click Here', bg_image: { url: 'https://via.placeholder.com/800' } } },
            'price-table': { widgetType: 'price-table', settings: { heading: 'Pro Plan', price: { size: 49 }, features_list: [{ item_text: 'Feature 1' }, { item_text: 'Feature 2' }] } },
            'price-list': { widgetType: 'price-list', settings: { price_list: [{ title: 'Item 1', price: '$10' }, { title: 'Item 2', price: '$20' }] } },
            'share-buttons': { widgetType: 'share-buttons', settings: { share_buttons: [{ social_icon: { value: 'fab fa-facebook', library: 'fa-brands' } }, { social_icon: { value: 'fab fa-twitter', library: 'fa-brands' } }] } },
            'paypal-button': { widgetType: 'paypal-button', settings: {} },
            'stripe-button': { widgetType: 'stripe-button', settings: {} },

            // Pro - Content & Layout
            'slides': { widgetType: 'slides', settings: { slides: [{ heading: 'Slide 1', description: 'Description 1' }, { heading: 'Slide 2', description: 'Description 2' }] } },
            'posts': { widgetType: 'posts', settings: {} },
            'portfolio': { widgetType: 'portfolio', settings: {} },
            'pro-gallery': { widgetType: 'pro-gallery', settings: {} },
            'animated-headline': { widgetType: 'animated-headline', settings: { before_text: 'This is', highlighted_text: 'Amazing', rotating_text: 'Amazing' } },
            'hotspot': { widgetType: 'hotspot', settings: { image: { url: 'https://via.placeholder.com/800' } } },
            'flip-box': { widgetType: 'flip-box', settings: { title_text_a: 'Front', title_text_b: 'Back', background_color_b: '#555555' } },
            'media-carousel': { widgetType: 'media-carousel', settings: { slides: [{ image: { url: 'https://via.placeholder.com/800' } }, { image: { url: 'https://via.placeholder.com/800' } }] } },
            'testimonial-carousel': { widgetType: 'testimonial-carousel', settings: { slides: [{ content: 'Great service!', name: 'John Doe' }] } },
            'reviews': { widgetType: 'reviews', settings: { slides: [{ name: 'Jane Doe', review: '5 stars' }] } },
            'table-of-contents': { widgetType: 'table-of-contents', settings: {} },
            'lottie': { widgetType: 'lottie', settings: { source_json: { url: '' } } },
            'code-highlight': { widgetType: 'code-highlight', settings: {} },
            'video-playlist': { widgetType: 'video-playlist', settings: { tabs: [{ title: 'Video 1', type: 'youtube', youtube_url: 'https://www.youtube.com/watch?v=XHOmBV4js_E' }] } },
            'progress-tracker': { widgetType: 'progress-tracker', settings: { items: [{ title: 'Step 1' }, { title: 'Step 2' }] } },
            'blockquote': { widgetType: 'blockquote', settings: { blockquote_content: 'To be or not to be.' } },
            'facebook-button': { widgetType: 'facebook-button', settings: {} },
            'facebook-comments': { widgetType: 'facebook-comments', settings: {} },
            'facebook-embed': { widgetType: 'facebook-embed', settings: {} },
            'facebook-page': { widgetType: 'facebook-page', settings: {} },
            'template': { widgetType: 'template', settings: {} },

            // WordPress / Woo
            'nav-menu': { widgetType: 'nav-menu', settings: {} },
            'search-form': { widgetType: 'search-form', settings: {} },
            'breadcrumbs': { widgetType: 'breadcrumbs', settings: {} },
            'sitemap': { widgetType: 'sitemap', settings: {} }
        };
    }

    compile(nodes) {
        var _this = this;
        var elements = nodes.filter(isVisible).map(function (node) {
            return _this.processNode(node);
        }).filter(Boolean);

        return {
            type: "elementor",
            siteurl: "",
            elements: elements,
            version: "3.2"
        };
    }

    processNode(node) {
        if (!isVisible(node)) return null;

        var name = node.name.toLowerCase();

        // --- 1. EXPLICIT WIDGET MAPPING (w:prefix) ---
        if (name.indexOf('w:') !== -1) {
            var match = name.match(/w:([a-z0-9-]+)/);
            if (match && match[1]) {
                var widgetSlug = match[1];

                // IMPORTANTE: "container" não é um widget, é um elType
                if (widgetSlug === 'container') {
                    return this.createContainer(node);
                }

                return this.createExplicitWidget(node, widgetSlug);
            }
        }

        // Legacy/Alias checks
        if (name.includes('button') || name.includes('btn')) return this.createExplicitWidget(node, 'button');

        // --- 2. STANDARD LOGIC ---

        // Safety Check
        var isLarge = node.width > 400 || node.height > 400;
        if (isLarge) {
            if (['FRAME', 'GROUP', 'INSTANCE', 'COMPONENT'].includes(node.type)) {
                return this.createContainer(node);
            }
            return null;
        }

        // Composite Detection
        if (['FRAME', 'GROUP', 'INSTANCE'].includes(node.type)) {
            var composite = this.detectCompositePattern(node);
            if (composite) return composite;
        }

        // Basic Inference
        if (this.hasImageFill(node)) {
            if (node.children && node.children.length > 0) return this.createContainer(node);
            return this.createExplicitWidget(node, 'image');
        }

        if (this.isIconNode(node)) return this.createExplicitWidget(node, 'icon');
        if (node.type === 'TEXT') return this.createTextWidget(node);

        // Default Container
        if (['FRAME', 'GROUP', 'INSTANCE', 'COMPONENT'].includes(node.type)) {
            return this.createContainer(node);
        }

        return null;
    }

    createExplicitWidget(node, widgetSlug) {
        var preset = this.widgetPresets[widgetSlug] || { widgetType: widgetSlug, settings: {} };
        var settings = JSON.parse(JSON.stringify(preset.settings));

        var textContent = [];
        var solidFills = [];

        if (node.children) {
            node.children.forEach(function (c) {
                if (c.type === 'TEXT') textContent.push(c.characters);
                if (c.fills && Array.isArray(c.fills)) {
                    c.fills.forEach(function (f) {
                        if (f.type === 'SOLID') solidFills.push(f);
                    });
                }
            });
        } else {
            if (node.type === 'TEXT') textContent.push(node.characters);
            if (node.fills && Array.isArray(node.fills)) {
                node.fills.forEach(function (f) {
                    if (f.type === 'SOLID') solidFills.push(f);
                });
            }
        }

        // Hidratar conteúdo de texto
        if (textContent.length > 0) {
            if (settings.title) settings.title = textContent[0];
            else if (settings.title_text) settings.title_text = textContent[0];
            else if (settings.heading) settings.heading = textContent[0];
            else if (settings.text) settings.text = textContent[0];
            else if (settings.editor) settings.editor = textContent[0];
        }
        if (textContent.length > 1) {
            if (settings.description) settings.description = textContent[1];
            else if (settings.description_text) settings.description_text = textContent[1];
            else if (settings.sub_heading) settings.sub_heading = textContent[1];
        }

        // Aplicar cores básicas
        if (solidFills.length > 0) {
            var color = convertColor(solidFills[0]);
            if (settings.title_color !== undefined) settings.title_color = color;
            else if (settings.primary_color !== undefined) settings.primary_color = color;
            else if (settings.button_background_color !== undefined) settings.button_background_color = color;
        }

        // Extrair estilos completos do nó
        var borders = extractBorderStyles(node);
        Object.assign(settings, borders);

        var shadows = extractShadows(node);
        Object.assign(settings, shadows);

        var background = extractBackgroundColor(node);
        Object.assign(settings, background);

        var padding = extractPadding(node);
        Object.assign(settings, padding);

        var dimensions = extractDimensions(node);
        // Para widgets, dimensões podem ser opcionais
        if (dimensions.width && dimensions.width.size < 1000) {
            Object.assign(settings, dimensions);
        }

        // NOVOS estilos (Fase 1)
        var opacity = extractOpacity(node);
        Object.assign(settings, opacity);

        var transform = extractTransform(node);
        Object.assign(settings, transform);

        // Text-shadow (se for texto ou tiver filhos de texto)
        if (node.type === 'TEXT' || (node.children && node.children.some(function (c) { return c.type === 'TEXT'; }))) {
            var textShadow = extractTextShadow(node);
            Object.assign(settings, textShadow);
        }

        return {
            id: generateGUID(),
            elType: 'widget',
            widgetType: preset.widgetType,
            settings: settings,
            elements: []
        };
    }

    detectCompositePattern(node) {
        if (!node.children) return null;
        var children = node.children.filter(isVisible);
        if (children.length < 2 || children.length > 4) return null;
        children.sort(function (a, b) { return a.y - b.y; });

        var hasIcon = false;
        var hasImage = false;
        var textCount = 0;

        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (this.isIconNode(child)) hasIcon = true;
            else if (this.hasImageFill(child)) hasImage = true;
            else if (child.type === 'TEXT') textCount++;
        }

        if (hasIcon && textCount >= 1 && !hasImage) return this.createExplicitWidget(node, 'icon-box');
        if (hasImage && textCount >= 1 && !hasIcon) return this.createExplicitWidget(node, 'image-box');

        return null;
    }

    isIconNode(node) {
        var isVector = ['VECTOR', 'STAR', 'ELLIPSE', 'POLYGON', 'BOOLEAN_OPERATION', 'LINE'].includes(node.type);
        var isSmallFrame = (node.type === 'FRAME' || node.type === 'INSTANCE') && node.width <= 50 && node.height <= 50;
        var name = node.name.toLowerCase();
        return isVector || isSmallFrame || name.includes('icon') || name.includes('vector');
    }

    hasImageFill(node) {
        return node.fills && Array.isArray(node.fills) && node.fills.some(function (p) { return p.type === 'IMAGE'; });
    }

    createContainer(node) {
        var _this = this;
        var isRow = node.layoutMode === 'HORIZONTAL';
        var settings = {
            flex_direction: isRow ? 'row' : 'column',
            content_width: 'full',
            width: { unit: '%', size: 100 }
        };

        // Alinhamento Flexbox
        if (node.primaryAxisAlignItems === 'CENTER') settings.justify_content = 'center';
        if (node.primaryAxisAlignItems === 'MAX') settings.justify_content = 'end';
        if (node.primaryAxisAlignItems === 'SPACE_BETWEEN') settings.justify_content = 'space-between';
        if (node.counterAxisAlignItems === 'CENTER') settings.align_items = 'center';
        if (node.counterAxisAlignItems === 'MAX') settings.align_items = 'end';
        if (node.itemSpacing > 0) settings.gap = { unit: 'px', size: node.itemSpacing };

        // Extrair estilos completos
        var padding = extractPadding(node);
        Object.assign(settings, padding);

        var borders = extractBorderStyles(node);
        Object.assign(settings, borders);

        var background = extractBackgroundColor(node);
        Object.assign(settings, background);

        var shadows = extractShadows(node);
        Object.assign(settings, shadows);

        var dimensions = extractDimensions(node);
        Object.assign(settings, dimensions);

        // NOVOS estilos (Fase 1)
        var opacity = extractOpacity(node);
        Object.assign(settings, opacity);

        var transform = extractTransform(node);
        Object.assign(settings, transform);

        var children = node.children.filter(isVisible).map(function (child) {
            return _this.processNode(child);
        }).filter(Boolean);

        return {
            id: generateGUID(),
            elType: 'container',
            settings: settings,
            elements: children,
            isInner: false
        };
    }

    createTextWidget(node) {
        var isHeading = (node.fontSize) > 24 || (node.fontName && node.fontName.style && node.fontName.style.toLowerCase().includes('bold'));
        var widgetType = isHeading ? 'heading' : 'text-editor';

        // Extrair TODOS os estilos
        var settings = {
            title: node.characters,
            editor: node.characters
        };

        // Tipografia completa
        var typo = extractTypography(node);
        Object.assign(settings, typo);

        // Cor do texto
        var textColor = extractTextColor(node);
        if (textColor) {
            settings.title_color = textColor;
            settings.text_color = textColor;
        }

        // Sombras
        var shadows = extractShadows(node);
        Object.assign(settings, shadows);

        // NOVOS estilos (Fase 1)
        var textShadow = extractTextShadow(node);
        Object.assign(settings, textShadow);

        var opacity = extractOpacity(node);
        Object.assign(settings, opacity);

        var transform = extractTransform(node);
        Object.assign(settings, transform);

        return {
            id: generateGUID(),
            elType: 'widget',
            widgetType: widgetType,
            settings: settings,
            elements: []
        };
    }

    debugNodeRecursive(node, depth) {
        if (depth > 5) return { type: node.type, id: node.id, note: "Max depth reached" };

        var info = {
            id: node.id,
            type: node.type,
            name: node.name,
            visible: node.visible !== false
        };

        // Dimensões
        if (node.width !== undefined) info.width = Math.round(node.width);
        if (node.height !== undefined) info.height = Math.round(node.height);

        // Posição
        if (node.x !== undefined) info.x = Math.round(node.x);
        if (node.y !== undefined) info.y = Math.round(node.y);

        // Texto
        if (node.type === 'TEXT') {
            info.characters = node.characters;
            if (node.fontSize) info.fontSize = node.fontSize;
            if (node.fontName) {
                info.fontFamily = node.fontName.family;
                info.fontStyle = node.fontName.style;
            }
            if (node.textAlignHorizontal) info.textAlign = node.textAlignHorizontal;
            if (node.lineHeight) info.lineHeight = node.lineHeight;
            if (node.letterSpacing) info.letterSpacing = node.letterSpacing;
        }

        // Fills (preenchimentos)
        if (node.fills && Array.isArray(node.fills) && node.fills.length > 0) {
            info.fills = node.fills.map(function (fill) {
                if (fill.type === 'SOLID') {
                    return {
                        type: 'SOLID',
                        color: convertColor(fill),
                        hex: convertColorToHex(fill),
                        opacity: fill.opacity || 1
                    };
                } else if (fill.type === 'IMAGE') {
                    return { type: 'IMAGE' };
                } else if (fill.type === 'GRADIENT_LINEAR' || fill.type === 'GRADIENT_RADIAL') {
                    return { type: fill.type, stops: fill.gradientStops ? fill.gradientStops.length : 0 };
                }
                return { type: fill.type };
            });
        }

        // Strokes (bordas)
        if (node.strokes && Array.isArray(node.strokes) && node.strokes.length > 0) {
            info.strokes = node.strokes.map(function (stroke) {
                return {
                    type: stroke.type,
                    color: convertColor(stroke)
                };
            });
            if (node.strokeWeight) info.strokeWeight = node.strokeWeight;
        }

        // Corner Radius
        if (node.cornerRadius !== undefined) {
            if (typeof node.cornerRadius === 'number') {
                info.cornerRadius = node.cornerRadius;
            } else {
                info.cornerRadius = {
                    topLeft: node.topLeftRadius || 0,
                    topRight: node.topRightRadius || 0,
                    bottomRight: node.bottomRightRadius || 0,
                    bottomLeft: node.bottomLeftRadius || 0
                };
            }
        }

        // Effects (sombras, blur, etc)
        if (node.effects && Array.isArray(node.effects) && node.effects.length > 0) {
            info.effects = node.effects.filter(function (e) { return e.visible !== false; }).map(function (effect) {
                if (effect.type === 'DROP_SHADOW') {
                    return {
                        type: 'DROP_SHADOW',
                        offset: { x: Math.round(effect.offset.x), y: Math.round(effect.offset.y) },
                        radius: Math.round(effect.radius),
                        spread: Math.round(effect.spread || 0),
                        color: 'rgba(' +
                            Math.round(effect.color.r * 255) + ', ' +
                            Math.round(effect.color.g * 255) + ', ' +
                            Math.round(effect.color.b * 255) + ', ' +
                            (effect.color.a || 1) + ')'
                    };
                }
                return { type: effect.type };
            });
        }

        // Padding (Auto Layout)
        if (node.paddingTop !== undefined || node.paddingLeft !== undefined) {
            info.padding = {
                top: node.paddingTop || 0,
                right: node.paddingRight || 0,
                bottom: node.paddingBottom || 0,
                left: node.paddingLeft || 0
            };
        }

        // Auto Layout
        if (node.layoutMode) {
            info.layoutMode = node.layoutMode;
            if (node.primaryAxisAlignItems) info.primaryAxisAlignItems = node.primaryAxisAlignItems;
            if (node.counterAxisAlignItems) info.counterAxisAlignItems = node.counterAxisAlignItems;
            if (node.itemSpacing) info.itemSpacing = node.itemSpacing;
        }

        // Opacity
        if (node.opacity !== undefined && node.opacity !== 1) {
            info.opacity = node.opacity;
        }

        // Rotation
        if (node.rotation !== undefined && node.rotation !== 0) {
            info.rotation = node.rotation;
        }

        // Estilos extraídos (preview do que será exportado)
        info.extractedStyles = {};

        if (node.type === 'TEXT') {
            var typo = extractTypography(node);
            if (Object.keys(typo).length > 0) info.extractedStyles.typography = typo;

            var textColor = extractTextColor(node);
            if (textColor) info.extractedStyles.textColor = textColor;

            var textShadow = extractTextShadow(node);
            if (Object.keys(textShadow).length > 0) info.extractedStyles.textShadow = textShadow;
        }

        var borders = extractBorderStyles(node);
        if (Object.keys(borders).length > 0) info.extractedStyles.borders = borders;

        var shadows = extractShadows(node);
        if (Object.keys(shadows).length > 0) info.extractedStyles.shadows = shadows;

        var background = extractBackgroundColor(node);
        if (Object.keys(background).length > 0) info.extractedStyles.background = background;

        var padding = extractPadding(node);
        if (Object.keys(padding).length > 0) info.extractedStyles.padding = padding;

        var opacity = extractOpacity(node);
        if (Object.keys(opacity).length > 0) info.extractedStyles.opacity = opacity;

        var transform = extractTransform(node);
        if (Object.keys(transform).length > 0) info.extractedStyles.transform = transform;

        // Children
        if (node.children) {
            var _this = this;
            info.children = node.children.map(function (c) { return _this.debugNodeRecursive(c, depth + 1); });
        }

        return info;
    }
}

figma.showUI(__html__, { width: 400, height: 600, themeColors: true });

figma.ui.onmessage = function (msg) {
    var compiler = new ElementorCompiler(msg.config);
    if (msg.type === 'export-elementor') {
        var result = compiler.compile(figma.currentPage.selection);
        figma.ui.postMessage({ type: 'export-result', data: JSON.stringify(result) });
    } else if (msg.type === 'debug-structure') {
        var dump = figma.currentPage.selection.map(function (n) { return compiler.debugNodeRecursive(n, 0); });
        figma.ui.postMessage({ type: 'debug-result', data: JSON.stringify(dump, null, 2) });
    } else if (msg.type === 'rename-layer') {
        if (figma.currentPage.selection.length === 0) {
            figma.notify("Selecione uma camada para aplicar o widget.");
            return;
        }
        figma.currentPage.selection.forEach(function (node) {
            node.name = msg.newName;
        });
        figma.notify("Camada(s) definida(s) como: " + msg.newName);
    } else if (msg.type === 'resize-window') {
        figma.ui.resize(msg.width, msg.height);
    }
};
